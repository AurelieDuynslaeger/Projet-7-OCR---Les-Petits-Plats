-------------- NOMINAL --------------------
3 caractères min dans la barre de Recherche
//query.lenght>= 3
//recherche dans le tableau d'objets appelé recipes 
    - .name (titre)
    - .Ingrédients[]
    - .description

const query

map->recipes

if name inclue query || ingredients.ingredient || description


interface actualisé
return recipe

champs de recherche avancés sont actualisés avec les infos 
    - Ingrédients (regroupe all ingredients de query)
    - Ustensiles (regroupe all ustencils de query)
    - Appareil (regroupe all appliance de query)

l'user précise sa recherche grâce à l'un des champs

à chaque lettre tapée, les mots clés NE CORRESPONDANT PAS disparaissent
 select -> search -> const search = map if search =! ingre/ustencils/applicances -> remove

l'user choix un mot clés
le mot clé apparait sous forme de tag
if clik -> tag


les résultats sont actualisés ainsi que les éléments dispo dans les champs de recherche avancée

query + tags -> return

l'user selectionne la recette
select recipe

-------------- ALTERNATIF 1 --------------------
aucune recherche ne correspond : 
    -> Les champs de recherche avancée sont actualisés avec les informations ingrédients, ustensiles, appareil des différentes recettes restantes

L’interface affiche « Aucune recette ne contient ‘XXX ’ vous pouvez chercher «tarte aux pommes », «poisson», etc. (le XXX correspond à ce que l’utilisateur a écrit
dans la recherche)

-------------- ALTERNATIF 2 --------------------
l'utilisateur commence sa recherche par tags
    -> 3 caractère min puis  Les résultats de recherche sont actualisés, ainsi que les éléments disponibles dans les champs de recherche avancée back ou selectionne une recette 


-------------- ALTERNATIF 3 -------------------
l'user ajoute d'autres tags pour la recherche avancée
    -> Les résultats de recherche sont actualisés, ainsi que les éléments disponibles dans les champs de recherche avancée, back ou sélectionne une recette
    -> L’utilisateur précise sa recherche grâce à l’un des champs : ingrédients,ustensiles, appareil.
    -> Au fur et à mesure du remplissage les mots clés ne correspondant pas à la frappe dans le champ disparaissent
    -> L’utilisateur choisit un mot clé dans le champ
    -> Le mot clé apparaît sous forme de tag sous la recherche principale
    -> Les résultats de recherche sont actualisés, ainsi que les éléments disponibles dans les champs de recherche avancée


# recherche possible via le champ principal ou par les tags
# recherche principale à partir de 3 caractères
# la recherche s'actualise à chaque caractère entré
# la recherche affiche les 3 premiers résultats le plus vite possible
# Les champs ingrédients, ustensiles et appareil de la recherche avancée proposent seulement les éléments restant dans les recettes présentes sur la page
# Les retours de recherche doivent être une intersection des résultats. Si l’on ajoute les tags “coco” et “chocolat” dans les ingrédients, on doit récupérer les recettes qui ont à la fois de la coco et du chocolat.
# Comme pour le reste du site, le code HTML et CSS pour l’interface devra passer avec succès le validateur W3C
# Aucune librairie ne sera utilisée pour le JavaScript du moteur de recherche



=========================================================
D’abord, planifie les 2 versions de la fonctionnalité que tu veux tester. Puisque tu vas traiter beaucoup de tableaux, ce serait intéressant de faire une version utilisant les boucles natives (while, for...) et une version en programmation fonctionnelle avec les méthodes de l'objet array (foreach, filter, map, reduce)
Ces deux implémentations doivent se focaliser uniquement sur le champ de recherche principal.
remplir le document d’investigation de fonctionnalité autant que tu peux pour bien décrire les deux implémentations que tu veux comparer.

implémentes tous les deux. Pour ça, utilise 2 branches différentes sur Git afin qu’on conserve bien le code séparé pour chacun. Pour ton implémentation, toutes les infos techniques sont sur le document du cas d’utilisation que t’a envoyé Sandra.

recherches par tag, tu pourras utiliser une seule et même version de la recherche pour les 2 branches.

Quand tu implémenteras ton code :  

découpe ton code au maximum en fonctions réutilisables, par exemple pour les cartes des recettes ou encore la génération des listes de tags
fais attention au risque d’injection de balises html ou toute autre faille de sécurité  dans le site via les formulaires.

Pour choisir le meilleur algorithme, il faut que tu testes leur performance. 
donnera le nombre d’opérations par seconde réalisées par chaque script et te permet donc de voir en un clin d’œil quel script est le plus performant.
Tu peux tester uniquement la recherche principale (pas besoin d’utiliser les filtres).
les résultats à la fiche d’investigation de fonctionnalité que tu auras rédigée. N’oublie pas de terminer le document par la recommandation d’algorithme à garder suite à ton analyse et tes tests.




C'est un projet intéressant et une comparaison entre les deux approches peut révéler des insights précieux. Voici comment vous pouvez structurer les premières étapes de votre projet en fonction de ce que vous avez décrit :

### Étapes Initiales du Projet

1. **Compréhension des Exigences :**
   - Bien comprendre les fonctionnalités du champ de recherche.
   - Définir les critères de recherche : par ingrédients, par nom de recette, par type de plat, etc.

2. **Préparation des Données :**
   - Structurer les 50 recettes dans un format exploitable (par exemple, un tableau d'objets JavaScript).
   - Chaque objet recette peut contenir des propriétés comme le nom, les ingrédients, le type de plat, le temps de cuisson, etc.

3. **Développement de l'Algorithme de Recherche avec Boucles Natives :**
   - Utiliser des boucles `for` ou `while` pour parcourir le tableau de recettes.
   - Comparer les critères de recherche avec les propriétés des objets recettes.
   - Retourner les recettes correspondantes.

4. **Développement de l'Algorithme de Recherche en Programmation Fonctionnelle :**
   - Utiliser les méthodes `forEach`, `filter`, `map`, et `reduce` de l'objet Array.
   - Filtrer les recettes en fonction des critères de recherche.
   - Comparer les résultats avec ceux obtenus via les boucles natives.

5. **Comparaison des Performances et de l'Impact Écologique :**
   - Mesurer le temps d'exécution des deux algorithmes pour différentes tailles de données.
   - Utiliser des outils pour estimer l'impact écologique (par exemple, consommation de CPU).

6. **Documentation et Analyse :**
   - Documenter le processus de développement pour chaque approche.
   - Analyser les résultats obtenus pour la performance et l'impact écologique.
   - Faire des recommandations basées sur les résultats de l'analyse.

### Exemple de Code

#### 1. Algorithme avec Boucles Natives
```javascript
function searchRecipesWithLoops(recipes, query) {
    let results = [];
    for (let i = 0; i < recipes.length; i++) {
        if (recipes[i].name.includes(query) || recipes[i].ingredients.includes(query)) {
            results.push(recipes[i]);
        }
    }
    return results;
}
```

#### 2. Algorithme en Programmation Fonctionnelle
```javascript
function searchRecipesWithFunctionalProgramming(recipes, query) {
    return recipes.filter(recipe => 
        recipe.name.includes(query) || recipe.ingredients.includes(query)
    );
}
```

### Exécution et Mesure des Performances
Vous pouvez utiliser `console.time` et `console.timeEnd` pour mesurer le temps d'exécution de chaque algorithme.

#### Exemple de Mesure de Performance
```javascript
console.time('Loops');
searchRecipesWithLoops(recipes, 'chicken');
console.timeEnd('Loops');

console.time('Functional');
searchRecipesWithFunctionalProgramming(recipes, 'chicken');
console.timeEnd('Functional');
```

### Conclusion
Ces étapes devraient vous fournir une base solide pour commencer votre projet. Assurez-vous de tester avec différentes tailles de données et divers critères de recherche pour obtenir des résultats représentatifs. Vous pouvez également envisager d'utiliser des outils de profiling plus avancés si nécessaire.
